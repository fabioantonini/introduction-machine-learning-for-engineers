{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e7ff399e-63a7-433f-b66d-0686a06ae8b6",
   "metadata": {},
   "source": [
    "# Multi-label classification problem\n",
    "In a multi-label classification problem, each instance can belong to multiple classes simultaneously. For example, an image might contain both a cat and a dog, and the model should predict both labels.\n",
    "\n",
    "## Example: Multi-Label Classification with TensorFlow\n",
    "We'll use a synthetic dataset for illustration, as most standard datasets are single-label. The key aspects of a multi-label classification model include:\n",
    "\n",
    "Output Layer: Use a sigmoid activation function instead of softmax, as sigmoid can handle multiple outputs independently.\n",
    "Loss Function: Use binary_crossentropy instead of categorical_crossentropy, as each label is considered independently.\n",
    "Hereâ€™s a complete example using TensorFlow:\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "55f24fb1-b2a9-4d46-a00c-9da357d8a931",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "from tensorflow.keras import layers, models\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Create a synthetic dataset\n",
    "def create_synthetic_data(num_samples=1000, img_size=(28, 28), num_labels=10):\n",
    "    X = np.random.rand(num_samples, *img_size, 1)  # Random images\n",
    "    y = np.random.randint(0, 2, (num_samples, num_labels))  # Random binary labels\n",
    "    return X, y\n",
    "\n",
    "# Generate synthetic training and testing data\n",
    "train_images, train_labels = create_synthetic_data()\n",
    "test_images, test_labels = create_synthetic_data()\n",
    "\n",
    "# Build the CNN model\n",
    "model = models.Sequential([\n",
    "    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),\n",
    "    layers.MaxPooling2D((2, 2)),\n",
    "    layers.Conv2D(64, (3, 3), activation='relu'),\n",
    "    layers.MaxPooling2D((2, 2)),\n",
    "    layers.Conv2D(64, (3, 3), activation='relu'),\n",
    "    layers.Flatten(),\n",
    "    layers.Dense(64, activation='relu'),\n",
    "    layers.Dense(10, activation='sigmoid')  # Multi-label classification uses sigmoid\n",
    "])\n",
    "\n",
    "# Compile the model\n",
    "model.compile(optimizer='adam',\n",
    "              loss='binary_crossentropy',  # Suitable for multi-label classification\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "# Train the model\n",
    "model.fit(train_images, train_labels, epochs=5, validation_data=(test_images, test_labels))\n",
    "\n",
    "# Evaluate the model\n",
    "test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)\n",
    "print(f'\\nTest accuracy: {test_acc}')\n",
    "\n",
    "# Make predictions on the test dataset\n",
    "predictions = model.predict(test_images)\n",
    "\n",
    "# Function to visualize the results\n",
    "def visualize_results(images, predictions, true_labels):\n",
    "    plt.figure(figsize=(10, 10))\n",
    "    for i in range(10):\n",
    "        plt.subplot(5, 5, i + 1)\n",
    "        plt.xticks([])\n",
    "        plt.yticks([])\n",
    "        plt.grid(False)\n",
    "        plt.imshow(images[i].squeeze(), cmap=plt.cm.binary)\n",
    "        pred_label = np.round(predictions[i]).astype(int)\n",
    "        true_label = true_labels[i]\n",
    "        plt.xlabel(f\"Pred: {pred_label}\\nTrue: {true_label}\")\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "# Visualize the first few predictions\n",
    "visualize_results(test_images, predictions, test_labels)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd81f2bb-7076-4c44-b603-782cd357b797",
   "metadata": {},
   "source": [
    "ctions\r\n",
    "visualize_results(test_images, predictions, test_labels)\r\n",
    "```\r\n",
    "\r\n",
    "### Key Points:\r\n",
    "1. **Synthetic Data Creation**: Since multi-label datasets aren't as common, synthetic data is used for illustration. In practice, you would use a dataset where each instance can have multiple labels.\r\n",
    "2. **Model Architecture**: The model ends with a dense layer with a `sigmoid` activation function, which allows for multiple outputs where each output node independently predicts the presence of a particular class.\r\n",
    "3. **Loss Function**: `binary_crossentropy` is used as the loss function, appropriate for multi-label classification where each label can be independently 0 or 1.\r\n",
    "4. **Evaluation and Visualization**: The model's predictions are visualized, showing both predicted and true labels.\r\n",
    "\r\n",
    "You can adjust the complexity of the model and the synthetic data generation process to better match real-world multi-label datasets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45efc250-4084-40e7-a78d-c0a61f942b8b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
